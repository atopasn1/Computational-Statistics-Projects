---
title: "Project2"
output: pdf_document
---

```{r}
library(tidyverse)
library(tidytuesdayR)
```
Part 1
```{r}
#1A
Exp <- function(x, k) {
  results <- 1 #note to self, you need to initialize something in a for loop in r, without this the function we just rewrite the result each time
    for (i in 1:k) {
      results <- results+(x^i)/factorial(i)
    }
    return(results)
}

Exp(5,2) #Output should be 18.5
```


```{r}
#1B
#sample mean
sample_mean <- function(x) {
      mean_res <-sum(x)/length(x)
      return(mean_res)
}
x <-c(18,21,22,3,5,15,16)
sample_mean(x)

#sample sd
sample_sd <- function(x) {
  N <- length(x)
  the_mean <- sample_mean(x)
    total <- 0 #again need to initialize
        for (i in 1:N) {
     total <- (total + (x[i]-the_mean)^2)
        }
  #this is the last part of the equation, separate because there is no need to   iterate over anything anymore
  deno <- (N-1)
  ans <- sqrt(total/deno)
  return(ans)
} 

sample_sd(x)


```

```{r}
#1C
calculate_CI <- function(x, conf = 0.95) {
    sd <- sample_sd(x)
    mean <- sample_mean(x)
    length <- length(x)
    
    alpha <- 1-conf
    se <- sd/sqrt(length)
    df <- length-1
    t_score <- qt(p = alpha / 2, df = df,lower.tail= FALSE)
    
    me <- t_score*se#to simplify writing the next setp
    
    upper_bound <- mean+me
    lower_bound <- mean-me
    
    return(c(lower_bound = lower_bound, upper_bound = upper_bound))#this could be taken out but I wanted to ensure that the lower and upper bounds appeared the way they did
}

calculate_CI(x, conf = 0.95)

calculate_CI(x, conf = 0.99)
```

Part2
```{r}
library(here)
if (!file.exists(here("data", "tuesdata_rainfall.RDS"))) {
    tuesdata <- tidytuesdayR::tt_load("2020-01-07")
    rainfall <- tuesdata$rainfall
    temperature <- tuesdata$temperature

    # save the files to RDS objects
    saveRDS(tuesdata$rainfall, file = here("data", "tuesdata_rainfall.RDS"))
    saveRDS(tuesdata$temperature, file = here("data", "tuesdata_temperature.RDS"))
}
```

```{r}
rainfall <- readRDS(here("data", "tuesdata_rainfall.RDS"))
temperature <- readRDS(here("data", "tuesdata_temperature.RDS"))
```

```{r}
#Part 1: Drop any NA values from rainfall
rainfall <- rainfall %>% 
  drop_na()

#Part2 
library(lubridate)
rainfall$date <-ymd(paste(rainfall$year,rainfall$month,rainfall$day, sep = "-"))

rainfall <- subset(rainfall, select= -c(month,day))

head(rainfall)

#Part3
rainfall$city_name <- toupper(rainfall$city_name) 

#Part4
join <- inner_join(rainfall, temperature, by = c("date", "city_name"))
nrow(join)
ncol(join)
```
Part 3
```{r}
#3a
#An overall title for the plot and a subtitle summarizing key trends that you found. Also include a caption in the figure.
#There should be an informative x-axis and y-axis label.

only_new <- join %>% 
  filter(year >= 2014)
graph1 <- ggplot(data = only_new, aes(x=date,y=temperature, color=temp_type))+
  geom_line()+
  facet_wrap(~city_name, ncol =2)+
  labs(x = "Time(years)", y= "Temperature(Celcius)", title = "High and Low Temperatures for Major Cities in Australia", subtitle = "Temperature fluctuations are seen both for max and minimum temperatures togethor more often than apart. ", color = "Temperature Type", caption = "Graph generated by Ana Topasna using the rainfall and temperature data sets")+
  theme_minimal()

graph1
```

```{r}
#3b
#The aim here is to design and implement a function that can be re-used to visualize all of the data in this dataset.
graph_it <- function(city_name,year){
  if(!(city_name %in% join$city_name)) {
    stop("Error: This city does not exist")
  }
  
  if(!(year %in% join$year)) {
    stop("Error: This year does not exist")
  }
  
  else if(sum(join$city_name == city_name & join$year == year) == 0) {
    stop("Error: This combo of city name and year is invalid") #the logic behind this section relies on TRUE and FALSE evaluation
  }

 rel <- join %>% 
  filter(city_name == city_name & year == year) %>% 
  ggplot(aes(log(rainfall)))+
   geom_histogram(fill = "lightblue")+
   labs(x="Rainfall (log transformed)", y = "Count of dates for a given rainfall", title = "Count of Rainfall in a Given City in Australia for a Given Year")
 
 return(rel)
}
#change the name of the title here

graph_it("PERTH",1994)


```
For this section, I first chose to write the error messages. So if the user does not have the correct city name from the join data set or the correct year, it will produce an error. In addition I include a stop/error message for when there is a combination of city and year that may exist separate in the data set, but does not exist together. Then, if the city name and year are correct, I used DPLYR to filter the input city name and the given year, used ggplot2 to return a histogram.



Part 4
```{r}
#4a
rain_df <- join %>% 
  filter(year >= 2014) %>% 
  group_by(city_name,year) %>% 
  summarize(
    mean = sample_mean(rainfall),
    sd = sample_sd(rainfall),
    lower_bound = calculate_CI(rainfall)[1], 
    upper_bound = calculate_CI(rainfall)[2],
    
  )
  
glimpse(rain_df)

#4b
ggplot(data = rain_df, aes(x=year,y = mean))+
  geom_point()+
  facet_wrap(~city_name)+
  geom_line()+
  geom_errorbar(aes(ymin = lower_bound, ymax = upper_bound))+
  labs(x = "Time(years)", y="Mean Rainfall", title = "Mean Rainfall For Major Cities in Australia", subtitle = "Mean rainfall for all cities has decreased either sharply or gradually ever since 2016", caption = "Made by Ana Topasna using the rainfall and temperature data set")
```

```{r}
#Example from class, good to have as notes
#for (i in names(penguins)) {
 #print(i)
 #var_data <- pull(penguins,i)
 #print(var_data)
 #if(is.numeric(var_data)){
   #print(mean(var_data, na.rm = TRUE))
 #}
 #else{
   #print("NA")
 #}
  #}
library(sessioninfo)
session_info()
```


